/*
    Purpose:
        Recursively list field information (field name, byte size, array dimensions, offset, and type)
        for all members of a specified C/C++ struct, including nested structs.
        The output is in CSV format to STDOUT with the following header:
        structName, offset, byteSize, array1length, array2length, classname.

    What is a PDB file:
        A Program Database (PDB) file is generated by the Microsoft Visual Studio C/C++ compiler and
        contains debugging and symbolic information about the compiled binary, including type definitions,
        function names, and variable locations. This tool extracts type layout details from the PDB.

    Relation to this project:
        The PDB file serves as the primary input to introspect and dump the internal layout
        of a struct defined in a C/C++ project compiled with Visual Studio.

    How to retrieve a PDB file:
        Build your project in Debug or Release mode in Visual Studio with Program Database (/Zi) and
        Generate Debug Info (/DEBUG) settings enabled. The compiler will emit a `.pdb` file alongside
        the `.exe` or `.dll` output.

    Requirements:
        - Visual Studio C++ compiler (e.g., VS2019)
        - PDB file corresponding to the binary
        - Microsoft DIA SDK registered and available (register msdia140.dll)
        - COM initialization (performed internally)

    Input:
        - Path to the `.pdb` file
        - Name of the struct to analyze

    Output:
        - CSV-formatted list of all field names and attributes to STDOUT
        - Includes nested field paths with offsets relative to the top-level struct

    Example use:
        Build your project with a struct of interest, then run:

            PDBFieldLister.exe path\to\binary.pdb MyStructName

        Output:
            MyStructName_Field1,0,4,1,1,int
            MyStructName_SubStruct_FieldA,4,8,1,1,double
            MyStructName_ArrayField,12,40,10,1,float
            ...

    License:
        Free to use, modify and distribute.
*/


#include <windows.h>
#include <dia2.h>
#include <atlbase.h>
#include <iostream>
#include <string>

#pragma comment(lib, "diaguids.lib")


// 0 is to built and give inputs
// 1 is to debug in VS ide, default inputs
#define DEBUG_MODE 1
// insert command line inputs below when working on debug mode
std::wstring debug_pdbPath      = L"./examplePdb/example.pdb";
std::wstring debug_targetStruct = L"MainStruct";

const wchar_t* GetBaseTypeName(DWORD baseType, DWORD size) {
    switch (baseType) {
    case btVoid:    return L"void";
    case btWChar:   return L"wchar_t";
    case btChar:    return L"int8";
    case btInt:     
        if (size == 1)
            return L"int8";
        else if (size == 2)
            return L"int16";
        else if (size == 4)
            return L"int32";
        else if (size == 8)
            return L"int64";
    case btUInt:
        if (size == 1)
            return L"uint8";
        else if (size == 2)
            return L"uint16";
        else if (size == 4)
            return L"uint32";
        else if (size == 8)
            return L"uint64";
    case btFloat:   
        if (size == 4) 
            return L"single"; 
        else if(size == 8) 
            return L"double";
    case btBool:    return L"bool";
    case btLong:    return L"long";
    case btULong:   return L"unsigned long";
    case btComplex: return L"complex";
    case btBSTR:    return L"BSTR";
    case btHresult: return L"HRESULT";
    default:        return L"<unknown base type>";
    }
}

void printStructFields(std::wstring field_name, LONG offset, ULONGLONG totalByteSize, DWORD size[2], const wchar_t* className) {
    std::wcout << field_name << L", " << offset << L", " << totalByteSize << L", " << size[0] << L", " << size[1] << L", " << className << std::endl;
}

void GetStructFields(IDiaSymbol* pSymbol, std::wstring prefix, const LONG startOffset) {

    std::wstring field_name; // combined fieldname with parent structs
    LONG offset = 0; // offset with respect to the input field name
    ULONGLONG totalByteSize = 0; // total byte size of the current field
        // Assumption: size is supported up to two dimensions
    DWORD size[2];
    std::wstring className;

    // get fields of the struct children ~ fields
    CComPtr<IDiaEnumSymbols> pEnumChildren;
    if (FAILED(pSymbol->findChildren(SymTagData, NULL, nsNone, &pEnumChildren)) || !pEnumChildren)
        return;

    ULONG celt = 0;
    CComPtr<IDiaSymbol> pChild;

    // do for all fields
    while (SUCCEEDED(pEnumChildren->Next(1, &pChild, &celt)) && celt == 1) {

        // name of the field
        BSTR name;


        CComPtr<IDiaSymbol> pType;
        pChild->get_name(&name);
        // combine with initial prefix of higher level struct names
        if(prefix != L"") {
            field_name = std::wstring(prefix) + L"." + name;
        }
        else {
            field_name = std::wstring(name);
        }
        pChild->get_offset(&offset);
        pChild->get_type(&pType);
        DWORD typeTag = 0;
        pType->get_symTag(&typeTag);
        DWORD typeId;
        pType->get_baseType(&typeId);

        if (pType) pType->get_length(&totalByteSize);
        if (pType) pType->get_count(&size[1]);


        int counter = 0;
        size[0] = size[1] = 1;
        while (typeTag == SymTagArrayType && counter < 2) {
            pType->get_count(&size[counter]);
            // check for deeper dimensions
            CComPtr<IDiaSymbol> innerElemType;
            pType->get_type(&innerElemType);
            pType = innerElemType;
            pType->get_symTag(&typeTag);
            counter++;
        }
        if (typeTag == SymTagBaseType || typeTag == SymTagEnum) {
            DWORD baseType = 0;
            if (SUCCEEDED(pType->get_baseType(&baseType))) {
                // add start offset and uppdate:
                offset += startOffset;
                printStructFields(field_name, offset, totalByteSize, size, GetBaseTypeName(baseType, totalByteSize / size[0] / size[1]));
            }
        }
        // subfield is union or struct, recurse
        else if (typeTag == SymTagUDT) {
            printStructFields(field_name, offset + startOffset, totalByteSize, size, L"struct");
            GetStructFields(pType, field_name, offset + startOffset);
        }
        else {
            std::wcout << L" unhandled symTag: " << typeTag << std::endl;
            return;
        }

        pChild.Release();
    }
}

int wmain(int argc, wchar_t* argv[]) {

    std::wstring pdbPath_, targetStruct_;
    if (DEBUG_MODE) {
        pdbPath_ = debug_pdbPath;
        targetStruct_ = debug_targetStruct;
    }
    else {
        if (argc != 3) {
            std::wcout << L"Usage: dump_struct_fields.exe <pdb_path> <struct_name>\n";
            return 1;
        }
        pdbPath_ = argv[1];
        targetStruct_ = argv[2];
    }
    const wchar_t* pdbPath = pdbPath_.c_str();
    const wchar_t* targetStruct = targetStruct_.c_str();


    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr)) {
        std::wcerr << L"Failed to initialize COM.\n";
        return 1;
    }

    CComPtr<IDiaDataSource> pSource;
    hr = CoCreateInstance(__uuidof(DiaSource), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pSource));
    if (FAILED(hr)) {
        std::wcerr << L"Failed to create DIA source.\n";
        return 1;
    }

    // load pdb
    if (FAILED(pSource->loadDataFromPdb(pdbPath))) {
        std::wcerr << L"Failed to load PDB file.\n" << pdbPath;
        return 1;
    }

    CComPtr<IDiaSession> pSession;
    if (FAILED(pSource->openSession(&pSession))) {
        std::wcerr << L"Failed to open DIA session.\n";
        return 1;
    }

    // get global scope
    CComPtr<IDiaSymbol> pGlobal;
    if (FAILED(pSession->get_globalScope(&pGlobal))) {
        std::wcerr << L"Failed to get global scope.\n";
        return 1;
    }

    // Search UDT (User Defined Types) within scope of pGlobal
    CComPtr<IDiaEnumSymbols> pEnum;
    if (FAILED(pGlobal->findChildren(SymTagUDT, targetStruct, nsCaseInsensitive, &pEnum))) {
        std::wcerr << L"Failed to find struct.\n";
        return 1;
    }

    // Parse first struct according to the input definition
    CComPtr<IDiaSymbol> pStruct;
    ULONG celt = 0;
    if (FAILED(pEnum->Next(1, &pStruct, &celt)) || celt == 0) {
        std::wcerr << L"Struct not found.\n";
        return 1;
    }

    // retrieve fields
    ULONGLONG totalByteSize = 0;
    if (pStruct) pStruct->get_length(&totalByteSize);
    DWORD typeTag = 0;
    pStruct->get_symTag(&typeTag);
    std::wcout << L"field_name, offset, byteSize, lengthDim1, lengthDim2, classname" << L"\n";
    DWORD size[2] = { 1,1 };
    printStructFields(targetStruct, 0, totalByteSize, size, L"struct");
    GetStructFields(pStruct, targetStruct, 0);

    //CoUninitialize();
    return 0;
}
